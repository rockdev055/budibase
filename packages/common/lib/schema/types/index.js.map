{"version":3,"sources":["../../../src/schema/types/index.js"],"names":["allTypes","basicTypes","string","number","datetime","bool","link","file","arrays","keys","k","kvType","concreteArray","name","types","assign","all","getType","typeName","BadRequestError","getSampleFieldValue","field","type","sampleValue","getNewFieldValue","getNew","safeParseField","record","validateFieldParse","tryParse","undefined","getDefaultOptions","validateTypeConstraints","detectType","value","JSON","stringify"],"mappings":"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","sourcesContent":["import { assign, merge } from \"lodash\"\nimport {\n  map,\n  isString,\n  isNumber,\n  isBoolean,\n  isDate,\n  keys,\n  isObject,\n  isArray,\n  has,\n} from \"lodash/fp\"\nimport { $ } from \"../../common\"\nimport { parsedSuccess } from \"./typeHelpers\"\nimport string from \"./string\"\nimport bool from \"./bool\"\nimport number from \"./number\"\nimport datetime from \"./datetime\"\nimport array from \"./array\"\nimport link from \"./link\"\nimport file from \"./file\"\nimport { BadRequestError } from \"../../common/errors\"\n\nconst allTypes = () => {\n  const basicTypes = {\n    string,\n    number,\n    datetime,\n    bool,\n    link,\n    file,\n  }\n\n  const arrays = $(basicTypes, [\n    keys,\n    map(k => {\n      const kvType = {}\n      const concreteArray = array(basicTypes[k])\n      kvType[concreteArray.name] = concreteArray\n      return kvType\n    }),\n    types => assign({}, ...types),\n  ])\n\n  return merge({}, basicTypes, arrays)\n}\n\nexport const all = allTypes()\n\nexport const getType = typeName => {\n  if (!has(typeName)(all))\n    throw new BadRequestError(`Do not recognise type ${typeName}`)\n  return all[typeName]\n}\n\nexport const getSampleFieldValue = field => getType(field.type).sampleValue\n\nexport const getNewFieldValue = field => getType(field.type).getNew(field)\n\nexport const safeParseField = (field, record) =>\n  getType(field.type).safeParseField(field, record)\n\nexport const validateFieldParse = (field, record) =>\n  has(field.name)(record)\n    ? getType(field.type).tryParse(record[field.name])\n    : parsedSuccess(undefined) // fields may be undefined by default\n\nexport const getDefaultOptions = type => getType(type).getDefaultOptions()\n\nexport const validateTypeConstraints = (field, record) =>\n  getType(field.type).validateTypeConstraints(field, record)\n\nexport const detectType = value => {\n  if (isString(value)) return string\n  if (isBoolean(value)) return bool\n  if (isNumber(value)) return number\n  if (isDate(value)) return datetime\n  if (isArray(value)) return array(detectType(value[0]))\n  if (isObject(value) && has(\"key\")(value) && has(\"value\")(value)) return link\n  if (isObject(value) && has(\"relativePath\")(value) && has(\"size\")(value))\n    return file\n\n  throw new BadRequestError(`cannot determine type: ${JSON.stringify(value)}`)\n}\n"],"file":"index.js"}