{"version":3,"sources":["../../../src/schema/types/array.js"],"names":["arrayFunctions","mapToParsedArrary","type","i","safeParseValue","parsedSuccess","arrayTryParse","isArray","defaultCase","parsedFailed","typeName","options","maxLength","defaultValue","isValid","isSafeInteger","requirementDescription","parse","toNumberOrNull","minLength","n","typeConstraints","val","opts","length","name","sampleValue","JSON","stringify"],"mappings":"uGAAA;AACA;;;;;;;AAOA;;;;;;;;AAQA,IAAMA,cAAc,GAAG,SAAjBA,cAAiB;AACrB,oCAAc;AACZ,iBAAS,kBAAS,EAAT,CADG,EAAd,CADqB,GAAvB;;;AAKA,IAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,CAAAC,IAAI;AAC5B;AACE,iBAAI,UAAAC,CAAC,UAAID,IAAI,CAACE,cAAL,CAAoBD,CAApB,CAAJ,EAAL,CADF;AAEEE,8BAFF,CAD4B,GAA9B;;;AAMA,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAAAJ,IAAI;AACxB,2BAAW,CAACK,WAAD,EAAUN,iBAAiB,CAACC,IAAD,CAA3B,CAAX,EAA+C,CAACM,kBAAD,EAAcC,yBAAd,CAA/C,CADwB,GAA1B;;AAGA,IAAMC,QAAQ,GAAG,SAAXA,QAAW,CAAAR,IAAI,0BAAaA,IAAb,QAArB;;AAEA,IAAMS,OAAO,GAAG;AACdC,EAAAA,SAAS,EAAE;AACTC,IAAAA,YAAY,EAAE,KADL;AAETC,IAAAA,OAAO,EAAEC,oBAFA;AAGTC,IAAAA,sBAAsB,EAAE,4BAHf;AAITC,IAAAA,KAAK,EAAEC,qBAJE,EADG;;AAOdC,EAAAA,SAAS,EAAE;AACTN,IAAAA,YAAY,EAAE,CADL;AAETC,IAAAA,OAAO,EAAE,iBAAAM,CAAC,UAAI,0BAAcA,CAAd,KAAoBA,CAAC,IAAI,CAA7B,EAFD;AAGTJ,IAAAA,sBAAsB,EAAE,4BAHf;AAITC,IAAAA,KAAK,EAAEC,qBAJE,EAPG,EAAhB;;;;AAeA,IAAMG,eAAe,GAAG;AACtB;AACE,UAACC,GAAD,EAAMC,IAAN,UAAeD,GAAG,KAAK,IAAR,IAAgBA,GAAG,CAACE,MAAJ,IAAcD,IAAI,CAACJ,SAAlD,EADF;AAEE,UAACG,GAAD,EAAMC,IAAN,gCAA8BA,IAAI,CAACJ,SAAnC,uBAFF,CADsB;;AAKtB;AACE,UAACG,GAAD,EAAMC,IAAN,UAAeD,GAAG,KAAK,IAAR,IAAgBA,GAAG,CAACE,MAAJ,IAAcD,IAAI,CAACX,SAAlD,EADF;AAEE,UAACU,GAAD,EAAMC,IAAN,4CAA0CA,IAAI,CAACX,SAA/C,eAFF,CALsB,CAAxB,C;;;;AAWe,kBAAAV,IAAI;AACjB;AACEQ,IAAAA,QAAQ,CAACR,IAAI,CAACuB,IAAN,CADV;AAEEnB,IAAAA,aAAa,CAACJ,IAAD,CAFf;AAGEF,IAAAA,cAAc,CAACE,IAAD,CAHhB;AAIES,IAAAA,OAJF;AAKEU,IAAAA,eALF;AAME,KAACnB,IAAI,CAACwB,WAAN,CANF;AAOEC,IAAAA,IAAI,CAACC,SAPP,CADiB,G","sourcesContent":["import { map, constant, isArray } from \"lodash/fp\"\nimport {\n  typeFunctions,\n  makerule,\n  parsedFailed,\n  getDefaultExport,\n  parsedSuccess,\n} from \"./typeHelpers\"\nimport {\n  switchCase,\n  defaultCase,\n  toNumberOrNull,\n  $$,\n  isSafeInteger,\n} from \"../../common/index.js\"\n\nconst arrayFunctions = () =>\n  typeFunctions({\n    default: constant([]),\n  })\n\nconst mapToParsedArrary = type =>\n  $$(\n    map(i => type.safeParseValue(i)),\n    parsedSuccess\n  )\n\nconst arrayTryParse = type =>\n  switchCase([isArray, mapToParsedArrary(type)], [defaultCase, parsedFailed])\n\nconst typeName = type => `array<${type}>`\n\nconst options = {\n  maxLength: {\n    defaultValue: 10000,\n    isValid: isSafeInteger,\n    requirementDescription: \"must be a positive integer\",\n    parse: toNumberOrNull,\n  },\n  minLength: {\n    defaultValue: 0,\n    isValid: n => isSafeInteger(n) && n >= 0,\n    requirementDescription: \"must be a positive integer\",\n    parse: toNumberOrNull,\n  },\n}\n\nconst typeConstraints = [\n  makerule(\n    (val, opts) => val === null || val.length >= opts.minLength,\n    (val, opts) => `must choose ${opts.minLength} or more options`\n  ),\n  makerule(\n    (val, opts) => val === null || val.length <= opts.maxLength,\n    (val, opts) => `cannot choose more than ${opts.maxLength} options`\n  ),\n]\n\nexport default type =>\n  getDefaultExport(\n    typeName(type.name),\n    arrayTryParse(type),\n    arrayFunctions(type),\n    options,\n    typeConstraints,\n    [type.sampleValue],\n    JSON.stringify\n  )\n"],"file":"array.js"}