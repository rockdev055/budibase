{"version":3,"sources":["../../../src/schema/types/file.js"],"names":["illegalCharacters","isLegalFilename","filePath","fn","fileName","length","split","f","fileNothing","relativePath","size","fileFunctions","fileTryParse","v","isValidFile","parsedSuccess","isNull","defaultCase","parsedFailed","splitKey","last","options","typeConstraints","JSON","stringify"],"mappings":"iIAAA;AACA;;;;;;AAMA;;;;;;;;AAQA,IAAMA,iBAAiB,GAAG,mBAA1B;;AAEO,IAAMC,eAAe,GAAG,SAAlBA,eAAkB,CAAAC,QAAQ,EAAI;AACzC,MAAMC,EAAE,GAAGC,QAAQ,CAACF,QAAD,CAAnB;AACA;AACEC,IAAAA,EAAE,CAACE,MAAH,IAAa,GAAb;AACA,0BAAaF,EAAE,CAACG,KAAH,CAAS,EAAT,CAAb,EAA2BN,iBAAiB,CAACM,KAAlB,CAAwB,EAAxB,CAA3B,EAAwDD,MAAxD,KAAmE,CADnE;AAEA,qBAAK,UAAAE,CAAC,UAAIA,CAAC,KAAK,IAAV,EAAN,EAAsB,qBAASL,QAAT,CAAtB,CAHF;;AAKD,CAPM,C;;AASP,IAAMM,WAAW,GAAG,SAAdA,WAAc,WAAO,EAAEC,YAAY,EAAE,EAAhB,EAAoBC,IAAI,EAAE,CAA1B,EAAP,EAApB;;AAEA,IAAMC,aAAa,GAAG,gCAAc;AAClC,aAASH,WADyB,EAAd,CAAtB;;;AAIA,IAAMI,YAAY,GAAG,SAAfA,YAAe,CAAAC,CAAC;AACpB;AACE,KAACC,WAAD,EAAcC,0BAAd,CADF;AAEE,KAACC,UAAD,EAAS,oBAAM,gCAAcR,WAAW,EAAzB,CAAN,EAAT,CAFF;AAGE,KAACS,kBAAD,EAAcC,yBAAd,CAHF;AAIEL,IAAAA,CAJF,CADoB,GAAtB;;AAOA,IAAMT,QAAQ,GAAG,SAAXA,QAAW,CAAAF,QAAQ,UAAI,cAAEA,QAAF,EAAY,CAACiB,eAAD,EAAWC,QAAX,CAAZ,CAAJ,EAAzB;;AAEA,IAAMN,WAAW,GAAG,SAAdA,WAAc,CAAAP,CAAC;AACnB,KAAC,gBAAOA,CAAP,CAAD;AACA,iBAAI,cAAJ,EAAoBA,CAApB,CADA;AAEA,iBAAI,MAAJ,EAAYA,CAAZ,CAFA;AAGA,sBAASA,CAAC,CAACG,IAAX,CAHA;AAIA,sBAASH,CAAC,CAACE,YAAX,CAJA;AAKAR,IAAAA,eAAe,CAACM,CAAC,CAACE,YAAH,CANI,GAArB;;AAQA,IAAMY,OAAO,GAAG,EAAhB;;AAEA,IAAMC,eAAe,GAAG,EAAxB,C;;AAEe;AACb,MADa;AAEbV,YAFa;AAGbD,aAHa;AAIbU,OAJa;AAKbC,eALa;AAMb,EAAEb,YAAY,EAAE,eAAhB,EAAiCC,IAAI,EAAE,IAAvC,EANa;AAOba,IAAI,CAACC,SAPQ,C","sourcesContent":["import { last, has, isString, intersection, isNull, isNumber } from \"lodash/fp\"\nimport {\n  typeFunctions,\n  parsedFailed,\n  parsedSuccess,\n  getDefaultExport,\n} from \"./typeHelpers\"\nimport {\n  switchCase,\n  defaultCase,\n  none,\n  $,\n  splitKey,\n} from \"../../common/index.js\"\n\nconst illegalCharacters = \"*?\\\\/:<>|\\0\\b\\f\\v\"\n\nexport const isLegalFilename = filePath => {\n  const fn = fileName(filePath)\n  return (\n    fn.length <= 255 &&\n    intersection(fn.split(\"\"))(illegalCharacters.split(\"\")).length === 0 &&\n    none(f => f === \"..\")(splitKey(filePath))\n  )\n}\n\nconst fileNothing = () => ({ relativePath: \"\", size: 0 })\n\nconst fileFunctions = typeFunctions({\n  default: fileNothing,\n})\n\nconst fileTryParse = v =>\n  switchCase(\n    [isValidFile, parsedSuccess],\n    [isNull, () => parsedSuccess(fileNothing())],\n    [defaultCase, parsedFailed]\n  )(v)\n\nconst fileName = filePath => $(filePath, [splitKey, last])\n\nconst isValidFile = f =>\n  !isNull(f) &&\n  has(\"relativePath\")(f) &&\n  has(\"size\")(f) &&\n  isNumber(f.size) &&\n  isString(f.relativePath) &&\n  isLegalFilename(f.relativePath)\n\nconst options = {}\n\nconst typeConstraints = []\n\nexport default getDefaultExport(\n  \"file\",\n  fileTryParse,\n  fileFunctions,\n  options,\n  typeConstraints,\n  { relativePath: \"some_file.jpg\", size: 1000 },\n  JSON.stringify\n)\n"],"file":"file.js"}