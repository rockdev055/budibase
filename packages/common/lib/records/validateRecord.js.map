{"version":3,"sources":["../../src/records/validateRecord.js"],"names":["fieldParseError","fieldName","value","fields","message","validateAllFieldParse","record","model","f","name","parseResult","errors","success","push","validateAllTypeConstraints","field","isNonEmptyString","m","e","runRecordValidationRules","runValidationRule","rule","isValid","expressionWhenValid","expressionContext","valid","invalidFields","messageWhenInvalid","validationRules","flatten","r","validateRecord","schema","findModel","_modelId","fieldParseFails","recordValidationRuleFails","typeContraintFails"],"mappings":"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","sourcesContent":["import { map, reduce, filter, isEmpty, flatten, each, union } from \"lodash/fp\";\r\nimport { compileCode } from \"../common/compileCode\";\r\nimport {\r\n  validateFieldParse,\r\n  validateTypeConstraints,\r\n} from \"../schema/types/index.js\"\r\nimport { $, isNonEmptyString } from \"../common/index.js\"\r\n\r\nconst fieldParseError = (fieldName, value) => ({\r\n  fields: [fieldName],\r\n  message: `Could not parse field ${fieldName}:${value}`,\r\n})\r\n\r\nconst validateAllFieldParse = (record, model) =>\r\n  $(model.fields, [\r\n    map(f => ({ name: f.name, parseResult: validateFieldParse(f, record) })),\r\n    reduce((errors, f) => {\r\n      if (f.parseResult.success) return errors\r\n      errors.push(fieldParseError(f.name, f.parseResult.value))\r\n      return errors\r\n    }, []),\r\n  ])\r\n\r\nconst validateAllTypeConstraints = (record, model) => {\r\n  const errors = []\r\n  for (const field of model.fields) {\r\n    $(validateTypeConstraints(field, record), [\r\n      filter(isNonEmptyString),\r\n      map(m => ({ message: m, fields: [field.name] })),\r\n      each(e => errors.push(e)),\r\n    ])\r\n  }\r\n  return errors\r\n}\r\n\r\nconst runRecordValidationRules = (record, model) => {\r\n  const runValidationRule = rule => {\r\n    const isValid = compileCode(rule.expressionWhenValid)\r\n    const expressionContext = { record }\r\n    return isValid(expressionContext)\r\n      ? { valid: true }\r\n      : {\r\n          valid: false,\r\n          fields: rule.invalidFields,\r\n          message: rule.messageWhenInvalid,\r\n        }\r\n  }\r\n\r\n  return $(model.validationRules, [\r\n    map(runValidationRule),\r\n    flatten,\r\n    filter(r => r.valid === false),\r\n    map(r => ({ fields: r.fields, message: r.message })),\r\n  ])\r\n}\r\n\r\nexport const validateRecord = (schema, record) => {\r\n  const model = schema.findModel(record._modelId)\r\n  const fieldParseFails = validateAllFieldParse(record, model)\r\n\r\n  // non parsing would cause further issues - exit here\r\n  if (!isEmpty(fieldParseFails)) {\r\n    return { isValid: false, errors: fieldParseFails }\r\n  }\r\n\r\n  const recordValidationRuleFails = runRecordValidationRules(record, model)\r\n  const typeContraintFails = validateAllTypeConstraints(record, model)\r\n\r\n  if (\r\n    isEmpty(fieldParseFails) &&\r\n    isEmpty(recordValidationRuleFails) &&\r\n    isEmpty(typeContraintFails)\r\n  ) {\r\n    return { isValid: true, errors: [] }\r\n  }\r\n\r\n  return {\r\n    isValid: false,\r\n    errors: union(\r\n      fieldParseFails,\r\n      typeContraintFails,\r\n      recordValidationRuleFails\r\n    ),\r\n  }\r\n}\r\n"],"file":"validateRecord.js"}